#include <stdio.h>
#include <math.h>
#include <stdlib.h>
#include <Windows.h>
#include "allegro5\allegro.h"
#include "allegro5\allegro_primitives.h"
#include "allegro5\allegro_color.h"
#include "C:\Temp\fm.c"

#define cor1  al_map_rgb(44, 117, 255)
#define cor2  al_map_rgb(117, 44, 255)
#define cor3  al_map_rgb(200, 117, 44)
#define cor4  al_map_rgb(244, 44, 117)

#define PRETO -4

#define WDT 800
#define HGT 600

#define LADO 50
#define SIZE 10

typedef struct ASDQWE {
	char ocupado;
	int cor;
} quadrado;


int pegaQuadrante(int *matriz, int size, int num) {
	int dec = num / 10, uni = num % 10;

	if (dec > 0 && dec <= size / 2)
		if (uni > 0 && dec <= 5)
			return 2;
		else
			return 1;
	else
		if (uni > 0 && dec <= size / 2)
			return 3;
		else
			return 4;

	return -1;
}
//Retorna a proxima posicao valida no quadrante desejado.
int proxPosNoQuad(int *matriz, int size, int quad) {
	int i, j, k;
	switch (quad) {
	case 1:
		for (i = 0, j = size / 2; i < size / 2, j < size; i++, j++) {
			k = i*size + j;
			if (pegaQuadrante(matriz, size, matriz[k]) != 1) {
				return k;
				break;
			}
		}
		break;
	case 2:
		for (i = 0, j = 0; i < size / 2, j < size / 2; i++, j++) {
			k = i*size + j;
			if (pegaQuadrante(matriz, size, matriz[k]) != 2) {
				return k;
				break;
			}
		}
		break;
	case 3:
		for (i = size / 2, j = 0; i < size, j < size / 2; i++, j++) {
			k = i*size + j;
			if (pegaQuadrante(matriz, size, matriz[k]) != 3) {
				return k;
				break;
			}
		}
		break;
	case 4:
		for (i = 0, j = size / 2; i < size / 2, j < size; i++, j++) {
			k = i*size + j;
			if (pegaQuadrante(matriz, size, matriz[k]) != 4) {
				return k;
				break;
			}
		}
		break;
	}

	return -10;
}

void movePeca(int *matriz, int size, int peca, int moveId) {
	switch (moveId) {
	case 1:
		//Mova para a direita
		permuta(&matriz[peca], &matriz[peca + 1]);
		break;
	case 2:
		//Mova para a esquerda
		permuta(&matriz[peca], &matriz[peca - 1]);
		break;
	case 3:
		//Mova para cima
		permuta(&matriz[peca], &matriz[peca - size]);
		break;
	case 4:
		//Mova para baixo
		permuta(&matriz[peca], &matriz[peca + size]);
		break;
	}
}

void descePeca(int *matriz, int size, int index) {
	int dec = index / 10, uni = index % 10;

	///1:DIR	2:ESQ	3:CIMA		4:BAIXO; baixo+direita+cima+esquerda+baixo

	movePeca(matriz, size, index, 4);
	movePeca(matriz, size, index, 1);
	movePeca(matriz, size, index, 3);
	movePeca(matriz, size, index, 2);
	movePeca(matriz, size, index, 4);
}
void sobePeca(int *matriz, int size, int index) {
	int dec = index / 10, uni = index % 10;
	///1:DIR	2:ESQ	3:CIMA		4:BAIXO
	movePeca(matriz, size, index, 3);
	movePeca(matriz, size, index, 1);
	movePeca(matriz, size, index, 4);
	movePeca(matriz, size, index, 2);
	movePeca(matriz, size, index, 3);

}
void esqPeca(int *matriz, int size, int index) {
	int dec = index / 10, uni = index % 10;
	///1:DIR	2:ESQ	3:CIMA		4:BAIXO;	direita+baixo/cima
	movePeca(matriz, size, index, 1);
	if (dec == 9) {
		movePeca(matriz, size, index, 4);
		movePeca(matriz, size, index, 2);
		movePeca(matriz, size, index, 2);
		movePeca(matriz, size, index, 3);
	}
	else {
		movePeca(matriz, size, index, 3);
		movePeca(matriz, size, index, 2);
		movePeca(matriz, size, index, 2);
		movePeca(matriz, size, index, 4);
	}
}
void dirPeca(int *matriz, int size, int index) {
	int dec = index / 10, uni = index % 10;
	///1:DIR	2:ESQ	3:CIMA		4:BAIXO
	if (dec == 9) {
		movePeca(matriz, size, index, 3);
		movePeca(matriz, size, index, 1);
		movePeca(matriz, size, index, 1);
		movePeca(matriz, size, index, 4);
	}
	else {
		movePeca(matriz, size, index, 4);
		movePeca(matriz, size, index, 1);
		movePeca(matriz, size, index, 1);
		movePeca(matriz, size, index, 3);
	}
}

int organiza(int *matriz, int size, int index) {
	int i, j, k, nilPos = 1000000, num, quad, dec = index / 10, uni = index % 10, proxPos, decProx, uniProx;
	//Loop que encontra a posicao da pedra preta
	for (i = 0; i < size; i++) {
		for (j = 0; j < size; j++) {
			k = i*size + j;
			if (matriz[k] == PRETO) {
				nilPos = k;
				break;
			}
		}
		if (nilPos != 1000000)
			break;
	}
	printf("A preta ta na %d \n", nilPos);
	num = matriz[index];
	quad = pegaQuadrante(matriz, size, num);
	///POE O PRETO DO LADO DO PRIMEIRO QUADRADO QUE PRECISA MECHER
	do {
		//Checa se esta na primeira metade do plano
		if (dec > 0 && dec <= size / 2) {
			//Checa se esta no segundo quadrante e na posicao certa
			if (uni > 0 && uni <= size / 2 && pegaQuadrante(matriz, size, num) != 2) {
				//Checa se o preto esta alem do quadrado a ser mechido. Caso sim, reduz nilPos ate alcancar o quadrado a ser mechido
				if (nilPos > index) {
					//Checa se pode pular uma linha, se nao, pula uma coluna
					if (nilPos % size < 1) {
						permuta(&matriz[nilPos], &matriz[nilPos -= size]);
					}
					else {
						permuta(&matriz[nilPos], &matriz[size--]);
					}
					pintaMatriz(matriz, size, LADO, PRETO);
					al_flip_display();
				}
				//nilPos esta atras de index na matriz
				else {
					if (nilPos % size < 1) {
						permuta(&matriz[nilPos], &matriz[nilPos += size]);
					}
					else {
						permuta(&matriz[nilPos], &matriz[nilPos++]);
					}
					pintaMatriz(matriz, size, LADO, PRETO);
					al_flip_display();
				}
			}
			//Esta no primeiro quadrante
			else {
				//Checa se o preto esta alem do quadrado a ser mechido. Caso sim, reduz nilPos ate alcancar o quadrado a ser mechido
				if (nilPos > index) {
					//Checa se pode pular uma linha, se nao, pula uma coluna
					if (nilPos % size < 1) {
						permuta(&matriz[nilPos], &matriz[nilPos -= size]);
					}
					else {
						permuta(&matriz[nilPos], &matriz[nilPos--]);
					}
					pintaMatriz(matriz, size, LADO, PRETO);
					al_flip_display();
				}
				//nilPos esta atras de index na matriz
				else {
					if (nilPos % size < 1) {
						permuta(&matriz[nilPos], &matriz[nilPos += size]);
					}
					else {
						permuta(&matriz[nilPos], &matriz[nilPos++]);
					}
					pintaMatriz(matriz, size, LADO, PRETO);
					al_flip_display();
				}

			}
		}
		//Esta na segunda metade
		else {
			//Checa se esta no segundo quadrante e na posicao certa
			if (uni > 0 && uni <= size / 2 && pegaQuadrante(matriz, size, num) != 3) {
				//Checa se o preto esta alem do quadrado a ser mechido. Caso sim, reduz nilPos ate alcancar o quadrado a ser mechido
				if (nilPos > index) {
					//Checa se pode pular uma linha, se nao, pula uma coluna
					if (nilPos % size < 1) {
						permuta(&matriz[nilPos], &matriz[nilPos -= size]);
					}
					else {
						permuta(&matriz[nilPos], &matriz[--nilPos]);
					}
				}
				//nilPos esta atras de index na matriz
				else {
					if (nilPos % size < 1) {
						permuta(&matriz[nilPos], &matriz[nilPos += size]);
					}
					else {
						permuta(&matriz[nilPos], &matriz[nilPos++]);
					}
				}
			}
			//Esta no primeiro quadrante
			else {
				//Checa se o preto esta alem do quadrado a ser mechido. Caso sim, reduz nilPos ate alcancar o quadrado a ser mechido
				if (nilPos > index) {
					//Checa se pode pular uma linha, se nao, pula uma coluna
					if (nilPos % size < 1) {
						permuta(&matriz[nilPos], &matriz[nilPos -= size]);
					}
					else {
						permuta(&matriz[nilPos], &matriz[nilPos--]);
					}
				}
				//nilPos esta atras de index na matriz
				else {
					if (nilPos % size < 1) {
						permuta(&matriz[nilPos], &matriz[nilPos += size]);
					}
					else {
						permuta(&matriz[nilPos], &matriz[nilPos++]);
					}
				}

			}
		}
		imprimeMatriz(matriz, size, size);
		pintaMatriz(matriz, size, LADO, PRETO);
		al_flip_display();
		Sleep(1000);
	} while (nilPos != index--);

	proxPos = proxPosNoQuad(matriz, 10, quad);

	printf("\nVOU COMECAR A TROCA!");
	/// A PEDRA ESTA EM POSICAO, COMECAR A TROCAR.
	do {
		decProx = proxPos / 10;
		uniProx = proxPos % 10;
		if (decProx == dec) {
			//Estao na mesma linha, mecha so as colunas
			if (uni == uniProx) {
				//A preta esta na posicao, trocar com o quadrado certo
				break;
			}
			else if (uni > uniProx) {
				//Reduza as colunas, mova a peca para a direita
				dirPeca(matriz, size, nilPos);
				pintaMatriz(matriz, size, LADO, PRETO);
				al_flip_display();

			}
			else {
				//Mova para a esquerda
				esqPeca(matriz, size, nilPos);
			}
		}
		else if (decProx > dec) {
			//Estao na mesma linha, mecha so as colunas
			if (uni == uniProx) {
				//A preta esta na posicao, trocar com o quadrado certo
				break;
			}
			else if (uni > uniProx) {
				//Reduza as linhas, mova para cima
				sobePeca(matriz, size, nilPos);
			}
			else {
				//Mova para baixo
				descePeca(matriz, size, nilPos);
			}
		}
		else {
			//Reduza as linhas at iguala-las
			if (uni == uniProx) {
				//A preta esta na posicao, trocar com o quadrado certo
				break;
			}
			else if (uni > uniProx) {
				//Reduza as colunas, mova a peca para a direita
				dirPeca(matriz, size, nilPos);
			}
			else {
				//Mova para a esquerda
				esqPeca(matriz, size, nilPos);
			}
		}
		pintaMatriz(matriz, size, LADO, PRETO);
		al_flip_display();
		printf("TO no loop");
	} while (proxPos != index);
	if (index < size)
		return organiza(matriz, size, index++);
	return 1;
}

int main() {

	if (!al_init()) {
		return -1;
	}

	if (!al_init_primitives_addon())
		return -1;

	ALLEGRO_DISPLAY *display = al_create_display(WDT, HGT);
	int plano[10][10];
	//////////POPULA A MATRIZ
	populaMatriz(&plano[0][0], SIZE);
	imprimeMatriz(&plano[0][0], SIZE, SIZE);
	pintaMatriz(&plano[0][0], SIZE, 50, PRETO);
	al_flip_display();
	Sleep(1000);
	///////////////
	printf("\n\n");
	/////////////////EMBARALHA A MATRIZ
	embaralhaVetor(&plano[0][0], SIZE*SIZE);
	plano[5][6] = PRETO;
	imprimeMatriz(&plano[0][0], 10, 10);
	pintaMatriz(&plano[0][0], SIZE, 50, PRETO);
	al_flip_display();
	/////////////////
	organiza(&plano[0][0], SIZE, 0);

	//printf("\n\n");
	//imprimeMatriz(&plano[0][0], 10, 10);
	system("pause");
	return 0;
}
